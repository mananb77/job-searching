{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __require = /* @__PURE__ */(x => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function (x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require2() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n    exports: {}\n  }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/fakeModules/process.js\nvar process;\nvar init_process = __esm({\n  \"src/fakeModules/process.js\"() {\n    \"use strict\";\n\n    process = {\n      env: {},\n      argv: {},\n      version: \"\",\n      versions: {},\n      platform: \"browser\",\n      browser: true,\n      cwd: () => \"/mock\"\n    };\n  }\n});\n\n// ../../node_modules/base64-js/index.js\nvar require_base64_js = __commonJS({\n  \"../../node_modules/base64-js/index.js\"(exports) {\n    \"use strict\";\n\n    init_process();\n    init_buffer();\n    exports.byteLength = byteLength;\n    exports.toByteArray = toByteArray;\n    exports.fromByteArray = fromByteArray;\n    var lookup = [];\n    var revLookup = [];\n    var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for (i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    }\n    var i;\n    var len;\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n    function getLens(b64) {\n      var len2 = b64.length;\n      if (len2 % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n      }\n      var validLen = b64.indexOf(\"=\");\n      if (validLen === -1) validLen = len2;\n      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n      return [validLen, placeHoldersLen];\n    }\n    function byteLength(b64) {\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function _byteLength(b64, validLen, placeHoldersLen) {\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function toByteArray(b64) {\n      var tmp;\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n      var curByte = 0;\n      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n      var i2;\n      for (i2 = 0; i2 < len2; i2 += 4) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      return arr;\n    }\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n    }\n    function encodeChunk(uint8, start, end) {\n      var tmp;\n      var output = [];\n      for (var i2 = start; i2 < end; i2 += 3) {\n        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n        output.push(tripletToBase64(tmp));\n      }\n      return output.join(\"\");\n    }\n    function fromByteArray(uint8) {\n      var tmp;\n      var len2 = uint8.length;\n      var extraBytes = len2 % 3;\n      var parts = [];\n      var maxChunkLength = 16383;\n      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n      }\n      if (extraBytes === 1) {\n        tmp = uint8[len2 - 1];\n        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n      } else if (extraBytes === 2) {\n        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n      }\n      return parts.join(\"\");\n    }\n  }\n});\n\n// ../../node_modules/ieee754/index.js\nvar require_ieee754 = __commonJS({\n  \"../../node_modules/ieee754/index.js\"(exports) {\n    init_process();\n    init_buffer();\n    exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n      var e, m;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = -7;\n      var i = isLE ? nBytes - 1 : 0;\n      var d = isLE ? -1 : 1;\n      var s = buffer[offset + i];\n      i += d;\n      e = s & (1 << -nBits) - 1;\n      s >>= -nBits;\n      nBits += eLen;\n      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n      m = e & (1 << -nBits) - 1;\n      e >>= -nBits;\n      nBits += mLen;\n      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n      } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n      }\n      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n    };\n    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n      var e, m, c;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n      var i = isLE ? 0 : nBytes - 1;\n      var d = isLE ? 1 : -1;\n      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n      value = Math.abs(value);\n      if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n      } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n          e--;\n          c *= 2;\n        }\n        if (e + eBias >= 1) {\n          value += rt / c;\n        } else {\n          value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n          e++;\n          c /= 2;\n        }\n        if (e + eBias >= eMax) {\n          m = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m = (value * c - 1) * Math.pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n          e = 0;\n        }\n      }\n      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}\n      e = e << mLen | m;\n      eLen += mLen;\n      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}\n      buffer[offset + i - d] |= s * 128;\n    };\n  }\n});\n\n// ../../node_modules/buffer/index.js\nvar require_buffer = __commonJS({\n  \"../../node_modules/buffer/index.js\"(exports) {\n    \"use strict\";\n\n    init_process();\n    init_buffer();\n    var base64 = require_base64_js();\n    var ieee754 = require_ieee754();\n    var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n    exports.Buffer = Buffer2;\n    exports.SlowBuffer = SlowBuffer;\n    exports.INSPECT_MAX_BYTES = 50;\n    var K_MAX_LENGTH = 2147483647;\n    exports.kMaxLength = K_MAX_LENGTH;\n    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n    }\n    function typedArraySupport() {\n      try {\n        const arr = new Uint8Array(1);\n        const proto = {\n          foo: function () {\n            return 42;\n          }\n        };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n      } catch (e) {\n        return false;\n      }\n    }\n    Object.defineProperty(Buffer2.prototype, \"parent\", {\n      enumerable: true,\n      get: function () {\n        if (!Buffer2.isBuffer(this)) return void 0;\n        return this.buffer;\n      }\n    });\n    Object.defineProperty(Buffer2.prototype, \"offset\", {\n      enumerable: true,\n      get: function () {\n        if (!Buffer2.isBuffer(this)) return void 0;\n        return this.byteOffset;\n      }\n    });\n    function createBuffer(length) {\n      if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n      }\n      const buf = new Uint8Array(length);\n      Object.setPrototypeOf(buf, Buffer2.prototype);\n      return buf;\n    }\n    function Buffer2(arg, encodingOrOffset, length) {\n      if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n          throw new TypeError('The \"string\" argument must be of type string. Received type number');\n        }\n        return allocUnsafe(arg);\n      }\n      return from(arg, encodingOrOffset, length);\n    }\n    Buffer2.poolSize = 8192;\n    function from(value, encodingOrOffset, length) {\n      if (typeof value === \"string\") {\n        return fromString(value, encodingOrOffset);\n      }\n      if (ArrayBuffer.isView(value)) {\n        return fromArrayView(value);\n      }\n      if (value == null) {\n        throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n      }\n      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof value === \"number\") {\n        throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n      }\n      const valueOf = value.valueOf && value.valueOf();\n      if (valueOf != null && valueOf !== value) {\n        return Buffer2.from(valueOf, encodingOrOffset, length);\n      }\n      const b = fromObject(value);\n      if (b) return b;\n      if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n        return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n      }\n      throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n    }\n    Buffer2.from = function (value, encodingOrOffset, length) {\n      return from(value, encodingOrOffset, length);\n    };\n    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);\n    Object.setPrototypeOf(Buffer2, Uint8Array);\n    function assertSize(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be of type number');\n      } else if (size < 0) {\n        throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      }\n    }\n    function alloc(size, fill, encoding) {\n      assertSize(size);\n      if (size <= 0) {\n        return createBuffer(size);\n      }\n      if (fill !== void 0) {\n        return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n      }\n      return createBuffer(size);\n    }\n    Buffer2.alloc = function (size, fill, encoding) {\n      return alloc(size, fill, encoding);\n    };\n    function allocUnsafe(size) {\n      assertSize(size);\n      return createBuffer(size < 0 ? 0 : checked(size) | 0);\n    }\n    Buffer2.allocUnsafe = function (size) {\n      return allocUnsafe(size);\n    };\n    Buffer2.allocUnsafeSlow = function (size) {\n      return allocUnsafe(size);\n    };\n    function fromString(string, encoding) {\n      if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n      }\n      if (!Buffer2.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      const length = byteLength(string, encoding) | 0;\n      let buf = createBuffer(length);\n      const actual = buf.write(string, encoding);\n      if (actual !== length) {\n        buf = buf.slice(0, actual);\n      }\n      return buf;\n    }\n    function fromArrayLike(array) {\n      const length = array.length < 0 ? 0 : checked(array.length) | 0;\n      const buf = createBuffer(length);\n      for (let i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n      }\n      return buf;\n    }\n    function fromArrayView(arrayView) {\n      if (isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n      }\n      return fromArrayLike(arrayView);\n    }\n    function fromArrayBuffer(array, byteOffset, length) {\n      if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n      }\n      if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n      }\n      let buf;\n      if (byteOffset === void 0 && length === void 0) {\n        buf = new Uint8Array(array);\n      } else if (length === void 0) {\n        buf = new Uint8Array(array, byteOffset);\n      } else {\n        buf = new Uint8Array(array, byteOffset, length);\n      }\n      Object.setPrototypeOf(buf, Buffer2.prototype);\n      return buf;\n    }\n    function fromObject(obj) {\n      if (Buffer2.isBuffer(obj)) {\n        const len = checked(obj.length) | 0;\n        const buf = createBuffer(len);\n        if (buf.length === 0) {\n          return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n      }\n      if (obj.length !== void 0) {\n        if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n          return createBuffer(0);\n        }\n        return fromArrayLike(obj);\n      }\n      if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data);\n      }\n    }\n    function checked(length) {\n      if (length >= K_MAX_LENGTH) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n      }\n      return length | 0;\n    }\n    function SlowBuffer(length) {\n      if (+length != length) {\n        length = 0;\n      }\n      return Buffer2.alloc(+length);\n    }\n    Buffer2.isBuffer = function isBuffer(b) {\n      return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n    };\n    Buffer2.compare = function compare(a, b) {\n      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);\n      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);\n      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n        throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n      }\n      if (a === b) return 0;\n      let x = a.length;\n      let y = b.length;\n      for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n          x = a[i];\n          y = b[i];\n          break;\n        }\n      }\n      if (x < y) return -1;\n      if (y < x) return 1;\n      return 0;\n    };\n    Buffer2.isEncoding = function isEncoding(encoding) {\n      switch (String(encoding).toLowerCase()) {\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return true;\n        default:\n          return false;\n      }\n    };\n    Buffer2.concat = function concat(list, length) {\n      if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      }\n      if (list.length === 0) {\n        return Buffer2.alloc(0);\n      }\n      let i;\n      if (length === void 0) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n          length += list[i].length;\n        }\n      }\n      const buffer = Buffer2.allocUnsafe(length);\n      let pos = 0;\n      for (i = 0; i < list.length; ++i) {\n        let buf = list[i];\n        if (isInstance(buf, Uint8Array)) {\n          if (pos + buf.length > buffer.length) {\n            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);\n            buf.copy(buffer, pos);\n          } else {\n            Uint8Array.prototype.set.call(buffer, buf, pos);\n          }\n        } else if (!Buffer2.isBuffer(buf)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        } else {\n          buf.copy(buffer, pos);\n        }\n        pos += buf.length;\n      }\n      return buffer;\n    };\n    function byteLength(string, encoding) {\n      if (Buffer2.isBuffer(string)) {\n        return string.length;\n      }\n      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength;\n      }\n      if (typeof string !== \"string\") {\n        throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);\n      }\n      const len = string.length;\n      const mustMatch = arguments.length > 2 && arguments[2] === true;\n      if (!mustMatch && len === 0) return 0;\n      let loweredCase = false;\n      for (;;) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8ToBytes(string).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n          case \"hex\":\n            return len >>> 1;\n          case \"base64\":\n            return base64ToBytes(string).length;\n          default:\n            if (loweredCase) {\n              return mustMatch ? -1 : utf8ToBytes(string).length;\n            }\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer2.byteLength = byteLength;\n    function slowToString(encoding, start, end) {\n      let loweredCase = false;\n      if (start === void 0 || start < 0) {\n        start = 0;\n      }\n      if (start > this.length) {\n        return \"\";\n      }\n      if (end === void 0 || end > this.length) {\n        end = this.length;\n      }\n      if (end <= 0) {\n        return \"\";\n      }\n      end >>>= 0;\n      start >>>= 0;\n      if (end <= start) {\n        return \"\";\n      }\n      if (!encoding) encoding = \"utf8\";\n      while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n          case \"base64\":\n            return base64Slice(this, start, end);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer2.prototype._isBuffer = true;\n    function swap(b, n, m) {\n      const i = b[n];\n      b[n] = b[m];\n      b[m] = i;\n    }\n    Buffer2.prototype.swap16 = function swap16() {\n      const len = this.length;\n      if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      }\n      for (let i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n      }\n      return this;\n    };\n    Buffer2.prototype.swap32 = function swap32() {\n      const len = this.length;\n      if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      }\n      for (let i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n      }\n      return this;\n    };\n    Buffer2.prototype.swap64 = function swap64() {\n      const len = this.length;\n      if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      }\n      for (let i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n      }\n      return this;\n    };\n    Buffer2.prototype.toString = function toString() {\n      const length = this.length;\n      if (length === 0) return \"\";\n      if (arguments.length === 0) return utf8Slice(this, 0, length);\n      return slowToString.apply(this, arguments);\n    };\n    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n    Buffer2.prototype.equals = function equals(b) {\n      if (!Buffer2.isBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n      if (this === b) return true;\n      return Buffer2.compare(this, b) === 0;\n    };\n    Buffer2.prototype.inspect = function inspect() {\n      let str = \"\";\n      const max = exports.INSPECT_MAX_BYTES;\n      str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n      if (this.length > max) str += \" ... \";\n      return \"<Buffer \" + str + \">\";\n    };\n    if (customInspectSymbol) {\n      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n    }\n    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n      if (isInstance(target, Uint8Array)) {\n        target = Buffer2.from(target, target.offset, target.byteLength);\n      }\n      if (!Buffer2.isBuffer(target)) {\n        throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);\n      }\n      if (start === void 0) {\n        start = 0;\n      }\n      if (end === void 0) {\n        end = target ? target.length : 0;\n      }\n      if (thisStart === void 0) {\n        thisStart = 0;\n      }\n      if (thisEnd === void 0) {\n        thisEnd = this.length;\n      }\n      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n      }\n      if (thisStart >= thisEnd && start >= end) {\n        return 0;\n      }\n      if (thisStart >= thisEnd) {\n        return -1;\n      }\n      if (start >= end) {\n        return 1;\n      }\n      start >>>= 0;\n      end >>>= 0;\n      thisStart >>>= 0;\n      thisEnd >>>= 0;\n      if (this === target) return 0;\n      let x = thisEnd - thisStart;\n      let y = end - start;\n      const len = Math.min(x, y);\n      const thisCopy = this.slice(thisStart, thisEnd);\n      const targetCopy = target.slice(start, end);\n      for (let i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n          x = thisCopy[i];\n          y = targetCopy[i];\n          break;\n        }\n      }\n      if (x < y) return -1;\n      if (y < x) return 1;\n      return 0;\n    };\n    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n      if (buffer.length === 0) return -1;\n      if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n      } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n      } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n      }\n      byteOffset = +byteOffset;\n      if (numberIsNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n      }\n      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n      if (byteOffset >= buffer.length) {\n        if (dir) return -1;else byteOffset = buffer.length - 1;\n      } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;else return -1;\n      }\n      if (typeof val === \"string\") {\n        val = Buffer2.from(val, encoding);\n      }\n      if (Buffer2.isBuffer(val)) {\n        if (val.length === 0) {\n          return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n          if (dir) {\n            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n          } else {\n            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n          }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n      }\n      throw new TypeError(\"val must be string, number or Buffer\");\n    }\n    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n      let indexSize = 1;\n      let arrLength = arr.length;\n      let valLength = val.length;\n      if (encoding !== void 0) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n          if (arr.length < 2 || val.length < 2) {\n            return -1;\n          }\n          indexSize = 2;\n          arrLength /= 2;\n          valLength /= 2;\n          byteOffset /= 2;\n        }\n      }\n      function read(buf, i2) {\n        if (indexSize === 1) {\n          return buf[i2];\n        } else {\n          return buf.readUInt16BE(i2 * indexSize);\n        }\n      }\n      let i;\n      if (dir) {\n        let foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n          } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n          }\n        }\n      } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n          let found = true;\n          for (let j = 0; j < valLength; j++) {\n            if (read(arr, i + j) !== read(val, j)) {\n              found = false;\n              break;\n            }\n          }\n          if (found) return i;\n        }\n      }\n      return -1;\n    }\n    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n      return this.indexOf(val, byteOffset, encoding) !== -1;\n    };\n    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n    };\n    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n    };\n    function hexWrite(buf, string, offset, length) {\n      offset = Number(offset) || 0;\n      const remaining = buf.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = Number(length);\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      const strLen = string.length;\n      if (length > strLen / 2) {\n        length = strLen / 2;\n      }\n      let i;\n      for (i = 0; i < length; ++i) {\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n      }\n      return i;\n    }\n    function utf8Write(buf, string, offset, length) {\n      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    function asciiWrite(buf, string, offset, length) {\n      return blitBuffer(asciiToBytes(string), buf, offset, length);\n    }\n    function base64Write(buf, string, offset, length) {\n      return blitBuffer(base64ToBytes(string), buf, offset, length);\n    }\n    function ucs2Write(buf, string, offset, length) {\n      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    Buffer2.prototype.write = function write(string, offset, length, encoding) {\n      if (offset === void 0) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n      } else if (length === void 0 && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n      } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n          length = length >>> 0;\n          if (encoding === void 0) encoding = \"utf8\";\n        } else {\n          encoding = length;\n          length = void 0;\n        }\n      } else {\n        throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n      }\n      const remaining = this.length - offset;\n      if (length === void 0 || length > remaining) length = remaining;\n      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n      }\n      if (!encoding) encoding = \"utf8\";\n      let loweredCase = false;\n      for (;;) {\n        switch (encoding) {\n          case \"hex\":\n            return hexWrite(this, string, offset, length);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Write(this, string, offset, length);\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return asciiWrite(this, string, offset, length);\n          case \"base64\":\n            return base64Write(this, string, offset, length);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return ucs2Write(this, string, offset, length);\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    };\n    Buffer2.prototype.toJSON = function toJSON() {\n      return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    };\n    function base64Slice(buf, start, end) {\n      if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n      } else {\n        return base64.fromByteArray(buf.slice(start, end));\n      }\n    }\n    function utf8Slice(buf, start, end) {\n      end = Math.min(buf.length, end);\n      const res = [];\n      let i = start;\n      while (i < end) {\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n          let secondByte, thirdByte, fourthByte, tempCodePoint;\n          switch (bytesPerSequence) {\n            case 1:\n              if (firstByte < 128) {\n                codePoint = firstByte;\n              }\n              break;\n            case 2:\n              secondByte = buf[i + 1];\n              if ((secondByte & 192) === 128) {\n                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                if (tempCodePoint > 127) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 3:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 4:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              fourthByte = buf[i + 3];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                  codePoint = tempCodePoint;\n                }\n              }\n          }\n        }\n        if (codePoint === null) {\n          codePoint = 65533;\n          bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n          codePoint -= 65536;\n          res.push(codePoint >>> 10 & 1023 | 55296);\n          codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n      }\n      return decodeCodePointsArray(res);\n    }\n    var MAX_ARGUMENTS_LENGTH = 4096;\n    function decodeCodePointsArray(codePoints) {\n      const len = codePoints.length;\n      if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n      }\n      let res = \"\";\n      let i = 0;\n      while (i < len) {\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n      }\n      return res;\n    }\n    function asciiSlice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n      }\n      return ret;\n    }\n    function latin1Slice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n      }\n      return ret;\n    }\n    function hexSlice(buf, start, end) {\n      const len = buf.length;\n      if (!start || start < 0) start = 0;\n      if (!end || end < 0 || end > len) end = len;\n      let out = \"\";\n      for (let i = start; i < end; ++i) {\n        out += hexSliceLookupTable[buf[i]];\n      }\n      return out;\n    }\n    function utf16leSlice(buf, start, end) {\n      const bytes = buf.slice(start, end);\n      let res = \"\";\n      for (let i = 0; i < bytes.length - 1; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n      }\n      return res;\n    }\n    Buffer2.prototype.slice = function slice(start, end) {\n      const len = this.length;\n      start = ~~start;\n      end = end === void 0 ? len : ~~end;\n      if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n      } else if (start > len) {\n        start = len;\n      }\n      if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n      } else if (end > len) {\n        end = len;\n      }\n      if (end < start) end = start;\n      const newBuf = this.subarray(start, end);\n      Object.setPrototypeOf(newBuf, Buffer2.prototype);\n      return newBuf;\n    };\n    function checkOffset(offset, ext, length) {\n      if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n      if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n    }\n    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      return val;\n    };\n    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        checkOffset(offset, byteLength2, this.length);\n      }\n      let val = this[offset + --byteLength2];\n      let mul = 1;\n      while (byteLength2 > 0 && (mul *= 256)) {\n        val += this[offset + --byteLength2] * mul;\n      }\n      return val;\n    };\n    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      return this[offset];\n    };\n    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] | this[offset + 1] << 8;\n    };\n    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] << 8 | this[offset + 1];\n    };\n    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n    };\n    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n    };\n    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n      return BigInt(lo) + (BigInt(hi) << BigInt(32));\n    });\n    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n      return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n    });\n    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let i = byteLength2;\n      let mul = 1;\n      let val = this[offset + --i];\n      while (i > 0 && (mul *= 256)) {\n        val += this[offset + --i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      if (!(this[offset] & 128)) return this[offset];\n      return (255 - this[offset] + 1) * -1;\n    };\n    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      const val = this[offset] | this[offset + 1] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      const val = this[offset + 1] | this[offset] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n    };\n    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n    };\n    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n    });\n    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n    });\n    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, true, 23, 4);\n    };\n    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, false, 23, 4);\n    };\n    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, true, 52, 8);\n    };\n    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, false, 52, 8);\n    };\n    function checkInt(buf, value, offset, ext, max, min) {\n      if (!Buffer2.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n      if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    }\n    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let mul = 1;\n      let i = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset + 3] = value >>> 24;\n      this[offset + 2] = value >>> 16;\n      this[offset + 1] = value >>> 8;\n      this[offset] = value & 255;\n      return offset + 4;\n    };\n    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    function wrtBigUInt64LE(buf, value, offset, min, max) {\n      checkIntBI(value, min, max, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      return offset;\n    }\n    function wrtBigUInt64BE(buf, value, offset, min, max) {\n      checkIntBI(value, min, max, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset + 7] = lo;\n      lo = lo >> 8;\n      buf[offset + 6] = lo;\n      lo = lo >> 8;\n      buf[offset + 5] = lo;\n      lo = lo >> 8;\n      buf[offset + 4] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset + 3] = hi;\n      hi = hi >> 8;\n      buf[offset + 2] = hi;\n      hi = hi >> 8;\n      buf[offset + 1] = hi;\n      hi = hi >> 8;\n      buf[offset] = hi;\n      return offset + 8;\n    }\n    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {\n      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {\n      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = 0;\n      let mul = 1;\n      let sub = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      let sub = 0;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);\n      if (value < 0) value = 255 + value + 1;\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      this[offset + 2] = value >>> 16;\n      this[offset + 3] = value >>> 24;\n      return offset + 4;\n    };\n    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      if (value < 0) value = 4294967295 + value + 1;\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {\n      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {\n      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    function checkIEEE754(buf, value, offset, ext, max, min) {\n      if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n      if (offset < 0) throw new RangeError(\"Index out of range\");\n    }\n    function writeFloat(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      return offset + 4;\n    }\n    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, true, noAssert);\n    };\n    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, false, noAssert);\n    };\n    function writeDouble(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      return offset + 8;\n    }\n    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, true, noAssert);\n    };\n    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, false, noAssert);\n    };\n    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n      if (!Buffer2.isBuffer(target)) throw new TypeError(\"argument should be a Buffer\");\n      if (!start) start = 0;\n      if (!end && end !== 0) end = this.length;\n      if (targetStart >= target.length) targetStart = target.length;\n      if (!targetStart) targetStart = 0;\n      if (end > 0 && end < start) end = start;\n      if (end === start) return 0;\n      if (target.length === 0 || this.length === 0) return 0;\n      if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n      }\n      if (start < 0 || start >= this.length) throw new RangeError(\"Index out of range\");\n      if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n      if (end > this.length) end = this.length;\n      if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n      }\n      const len = end - start;\n      if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n        this.copyWithin(targetStart, start, end);\n      } else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n      }\n      return len;\n    };\n    Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n      if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n          encoding = start;\n          start = 0;\n          end = this.length;\n        } else if (typeof end === \"string\") {\n          encoding = end;\n          end = this.length;\n        }\n        if (encoding !== void 0 && typeof encoding !== \"string\") {\n          throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        if (val.length === 1) {\n          const code = val.charCodeAt(0);\n          if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n            val = code;\n          }\n        }\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n      } else if (typeof val === \"boolean\") {\n        val = Number(val);\n      }\n      if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n      }\n      if (end <= start) {\n        return this;\n      }\n      start = start >>> 0;\n      end = end === void 0 ? this.length : end >>> 0;\n      if (!val) val = 0;\n      let i;\n      if (typeof val === \"number\") {\n        for (i = start; i < end; ++i) {\n          this[i] = val;\n        }\n      } else {\n        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) {\n          throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        }\n        for (i = 0; i < end - start; ++i) {\n          this[i + start] = bytes[i % len];\n        }\n      }\n      return this;\n    };\n    var errors = {};\n    function E(sym, getMessage, Base) {\n      errors[sym] = class NodeError extends Base {\n        constructor() {\n          super();\n          Object.defineProperty(this, \"message\", {\n            value: getMessage.apply(this, arguments),\n            writable: true,\n            configurable: true\n          });\n          this.name = `${this.name} [${sym}]`;\n          this.stack;\n          delete this.name;\n        }\n        get code() {\n          return sym;\n        }\n        set code(value) {\n          Object.defineProperty(this, \"code\", {\n            configurable: true,\n            enumerable: true,\n            value,\n            writable: true\n          });\n        }\n        toString() {\n          return `${this.name} [${sym}]: ${this.message}`;\n        }\n      };\n    }\n    E(\"ERR_BUFFER_OUT_OF_BOUNDS\", function (name) {\n      if (name) {\n        return `${name} is outside of buffer bounds`;\n      }\n      return \"Attempt to access memory outside buffer bounds\";\n    }, RangeError);\n    E(\"ERR_INVALID_ARG_TYPE\", function (name, actual) {\n      return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n    }, TypeError);\n    E(\"ERR_OUT_OF_RANGE\", function (str, range, input) {\n      let msg = `The value of \"${str}\" is out of range.`;\n      let received = input;\n      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n        received = addNumericalSeparator(String(input));\n      } else if (typeof input === \"bigint\") {\n        received = String(input);\n        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n          received = addNumericalSeparator(received);\n        }\n        received += \"n\";\n      }\n      msg += ` It must be ${range}. Received ${received}`;\n      return msg;\n    }, RangeError);\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    function checkBounds(buf, offset, byteLength2) {\n      validateNumber(offset, \"offset\");\n      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n        boundsError(offset, buf.length - (byteLength2 + 1));\n      }\n    }\n    function checkIntBI(value, min, max, buf, offset, byteLength2) {\n      if (value > max || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        if (byteLength2 > 3) {\n          if (min === 0 || min === BigInt(0)) {\n            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n          } else {\n            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n          }\n        } else {\n          range = `>= ${min}${n} and <= ${max}${n}`;\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n      }\n      checkBounds(buf, offset, byteLength2);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") {\n        throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n    }\n    function boundsError(value, length, type) {\n      if (Math.floor(value) !== value) {\n        validateNumber(value, type);\n        throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n      }\n      if (length < 0) {\n        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n      }\n      throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", `>= ${type ? 1 : 0} and <= ${length}`, value);\n    }\n    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n    function base64clean(str) {\n      str = str.split(\"=\")[0];\n      str = str.trim().replace(INVALID_BASE64_RE, \"\");\n      if (str.length < 2) return \"\";\n      while (str.length % 4 !== 0) {\n        str = str + \"=\";\n      }\n      return str;\n    }\n    function utf8ToBytes(string, units) {\n      units = units || Infinity;\n      let codePoint;\n      const length = string.length;\n      let leadSurrogate = null;\n      const bytes = [];\n      for (let i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n          if (!leadSurrogate) {\n            if (codePoint > 56319) {\n              if ((units -= 3) > -1) bytes.push(239, 191, 189);\n              continue;\n            } else if (i + 1 === length) {\n              if ((units -= 3) > -1) bytes.push(239, 191, 189);\n              continue;\n            }\n            leadSurrogate = codePoint;\n            continue;\n          }\n          if (codePoint < 56320) {\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n            leadSurrogate = codePoint;\n            continue;\n          }\n          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n          if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n          if ((units -= 1) < 0) break;\n          bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n          if ((units -= 2) < 0) break;\n          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n        } else if (codePoint < 65536) {\n          if ((units -= 3) < 0) break;\n          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else if (codePoint < 1114112) {\n          if ((units -= 4) < 0) break;\n          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else {\n          throw new Error(\"Invalid code point\");\n        }\n      }\n      return bytes;\n    }\n    function asciiToBytes(str) {\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        byteArray.push(str.charCodeAt(i) & 255);\n      }\n      return byteArray;\n    }\n    function utf16leToBytes(str, units) {\n      let c, hi, lo;\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n      }\n      return byteArray;\n    }\n    function base64ToBytes(str) {\n      return base64.toByteArray(base64clean(str));\n    }\n    function blitBuffer(src, dst, offset, length) {\n      let i;\n      for (i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n      }\n      return i;\n    }\n    function isInstance(obj, type) {\n      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n    }\n    function numberIsNaN(obj) {\n      return obj !== obj;\n    }\n    var hexSliceLookupTable = function () {\n      const alphabet = \"0123456789abcdef\";\n      const table = new Array(256);\n      for (let i = 0; i < 16; ++i) {\n        const i16 = i * 16;\n        for (let j = 0; j < 16; ++j) {\n          table[i16 + j] = alphabet[i] + alphabet[j];\n        }\n      }\n      return table;\n    }();\n    function defineBigIntMethod(fn) {\n      return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n    }\n    function BufferBigIntNotDefined() {\n      throw new Error(\"BigInt not supported\");\n    }\n  }\n});\n\n// src/fakeModules/buffer.js\nvar import_buffer;\nvar init_buffer = __esm({\n  \"src/fakeModules/buffer.js\"() {\n    \"use strict\";\n\n    import_buffer = __toESM(require_buffer());\n  }\n});\nexport { __require, __esm, __commonJS, __export, __toESM, __toCommonJS, process, init_process, require_buffer, import_buffer, init_buffer };\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */","map":{"version":3,"names":["__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__require","x","require","Proxy","get","a","b","apply","arguments","Error","__esm","fn","res","__init","__commonJS","cb","mod","__require2","exports","__export","target","all","name","enumerable","__copyProps","to","from","except","desc","key","call","__toESM","isNodeMode","__esModule","value","__toCommonJS","process","init_process","env","argv","version","versions","platform","browser","cwd","require_base64_js","init_buffer","byteLength","toByteArray","fromByteArray","lookup","revLookup","Arr","Uint8Array","Array","code","i","len","length","charCodeAt","getLens","b64","len2","validLen","indexOf","placeHoldersLen","lens","_byteLength","tmp","arr","curByte","i2","tripletToBase64","num","encodeChunk","uint8","start","end","output","push","join","extraBytes","parts","maxChunkLength","len22","require_ieee754","read","buffer","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","d","s","NaN","Infinity","Math","pow","write","c","rt","abs","isNaN","floor","log","LN2","require_buffer","base64","ieee754","customInspectSymbol","Symbol","Buffer","Buffer2","SlowBuffer","INSPECT_MAX_BYTES","K_MAX_LENGTH","kMaxLength","TYPED_ARRAY_SUPPORT","typedArraySupport","console","error","proto","foo","setPrototypeOf","isBuffer","byteOffset","createBuffer","RangeError","buf","arg","encodingOrOffset","TypeError","allocUnsafe","poolSize","fromString","ArrayBuffer","isView","fromArrayView","isInstance","fromArrayBuffer","SharedArrayBuffer","valueOf","fromObject","toPrimitive","assertSize","size","alloc","fill","encoding","checked","allocUnsafeSlow","string","isEncoding","actual","slice","fromArrayLike","array","arrayView","copy","obj","numberIsNaN","type","isArray","data","toString","_isBuffer","compare","y","min","String","toLowerCase","concat","list","pos","set","mustMatch","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","swap16","swap32","swap64","toLocaleString","equals","inspect","str","max","replace","trim","thisStart","thisEnd","thisCopy","targetCopy","bidirectionalIndexOf","val","dir","arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","readUInt16BE","foundIndex","found","j","includes","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","base64Write","ucs2Write","utf16leToBytes","isFinite","toJSON","_arr","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","fromCharCode","ret","out","hexSliceLookupTable","bytes","newBuf","subarray","checkOffset","ext","readUintLE","readUIntLE","byteLength2","noAssert","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","first","last","boundsError","lo","hi","BigInt","readBigUInt64BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","checkInt","writeUintLE","writeUIntLE","maxBytes","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","wrtBigUInt64LE","checkIntBI","wrtBigUInt64BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","checkIEEE754","writeFloat","littleEndian","writeFloatLE","writeFloatBE","writeDouble","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","errors","E","sym","getMessage","Base","NodeError","constructor","writable","configurable","stack","message","range","input","msg","received","isInteger","addNumericalSeparator","checkBounds","ERR_OUT_OF_RANGE","ERR_INVALID_ARG_TYPE","ERR_BUFFER_OUT_OF_BOUNDS","INVALID_BASE64_RE","base64clean","split","units","leadSurrogate","byteArray","src","dst","alphabet","table","i16","BufferBigIntNotDefined","import_buffer"],"sources":["/Users/mohammedabed/node_modules/vivid-studio/dist/chunk-AZLL6FY2.mjs"],"sourcesContent":["var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require2() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/fakeModules/process.js\nvar process;\nvar init_process = __esm({\n  \"src/fakeModules/process.js\"() {\n    \"use strict\";\n    process = {\n      env: {},\n      argv: {},\n      version: \"\",\n      versions: {},\n      platform: \"browser\",\n      browser: true,\n      cwd: () => \"/mock\"\n    };\n  }\n});\n\n// ../../node_modules/base64-js/index.js\nvar require_base64_js = __commonJS({\n  \"../../node_modules/base64-js/index.js\"(exports) {\n    \"use strict\";\n    init_process();\n    init_buffer();\n    exports.byteLength = byteLength;\n    exports.toByteArray = toByteArray;\n    exports.fromByteArray = fromByteArray;\n    var lookup = [];\n    var revLookup = [];\n    var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for (i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    }\n    var i;\n    var len;\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n    function getLens(b64) {\n      var len2 = b64.length;\n      if (len2 % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n      }\n      var validLen = b64.indexOf(\"=\");\n      if (validLen === -1)\n        validLen = len2;\n      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n      return [validLen, placeHoldersLen];\n    }\n    function byteLength(b64) {\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function _byteLength(b64, validLen, placeHoldersLen) {\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function toByteArray(b64) {\n      var tmp;\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n      var curByte = 0;\n      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n      var i2;\n      for (i2 = 0; i2 < len2; i2 += 4) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      return arr;\n    }\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n    }\n    function encodeChunk(uint8, start, end) {\n      var tmp;\n      var output = [];\n      for (var i2 = start; i2 < end; i2 += 3) {\n        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n        output.push(tripletToBase64(tmp));\n      }\n      return output.join(\"\");\n    }\n    function fromByteArray(uint8) {\n      var tmp;\n      var len2 = uint8.length;\n      var extraBytes = len2 % 3;\n      var parts = [];\n      var maxChunkLength = 16383;\n      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n      }\n      if (extraBytes === 1) {\n        tmp = uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n        );\n      } else if (extraBytes === 2) {\n        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n        );\n      }\n      return parts.join(\"\");\n    }\n  }\n});\n\n// ../../node_modules/ieee754/index.js\nvar require_ieee754 = __commonJS({\n  \"../../node_modules/ieee754/index.js\"(exports) {\n    init_process();\n    init_buffer();\n    exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n      var e, m;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = -7;\n      var i = isLE ? nBytes - 1 : 0;\n      var d = isLE ? -1 : 1;\n      var s = buffer[offset + i];\n      i += d;\n      e = s & (1 << -nBits) - 1;\n      s >>= -nBits;\n      nBits += eLen;\n      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n      }\n      m = e & (1 << -nBits) - 1;\n      e >>= -nBits;\n      nBits += mLen;\n      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n      }\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n      } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n      }\n      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n    };\n    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n      var e, m, c;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n      var i = isLE ? 0 : nBytes - 1;\n      var d = isLE ? 1 : -1;\n      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n      value = Math.abs(value);\n      if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n      } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n          e--;\n          c *= 2;\n        }\n        if (e + eBias >= 1) {\n          value += rt / c;\n        } else {\n          value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n          e++;\n          c /= 2;\n        }\n        if (e + eBias >= eMax) {\n          m = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m = (value * c - 1) * Math.pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n          e = 0;\n        }\n      }\n      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n      }\n      e = e << mLen | m;\n      eLen += mLen;\n      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n      }\n      buffer[offset + i - d] |= s * 128;\n    };\n  }\n});\n\n// ../../node_modules/buffer/index.js\nvar require_buffer = __commonJS({\n  \"../../node_modules/buffer/index.js\"(exports) {\n    \"use strict\";\n    init_process();\n    init_buffer();\n    var base64 = require_base64_js();\n    var ieee754 = require_ieee754();\n    var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n    exports.Buffer = Buffer2;\n    exports.SlowBuffer = SlowBuffer;\n    exports.INSPECT_MAX_BYTES = 50;\n    var K_MAX_LENGTH = 2147483647;\n    exports.kMaxLength = K_MAX_LENGTH;\n    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\n        \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n      );\n    }\n    function typedArraySupport() {\n      try {\n        const arr = new Uint8Array(1);\n        const proto = { foo: function() {\n          return 42;\n        } };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n      } catch (e) {\n        return false;\n      }\n    }\n    Object.defineProperty(Buffer2.prototype, \"parent\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer2.isBuffer(this))\n          return void 0;\n        return this.buffer;\n      }\n    });\n    Object.defineProperty(Buffer2.prototype, \"offset\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer2.isBuffer(this))\n          return void 0;\n        return this.byteOffset;\n      }\n    });\n    function createBuffer(length) {\n      if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n      }\n      const buf = new Uint8Array(length);\n      Object.setPrototypeOf(buf, Buffer2.prototype);\n      return buf;\n    }\n    function Buffer2(arg, encodingOrOffset, length) {\n      if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be of type string. Received type number'\n          );\n        }\n        return allocUnsafe(arg);\n      }\n      return from(arg, encodingOrOffset, length);\n    }\n    Buffer2.poolSize = 8192;\n    function from(value, encodingOrOffset, length) {\n      if (typeof value === \"string\") {\n        return fromString(value, encodingOrOffset);\n      }\n      if (ArrayBuffer.isView(value)) {\n        return fromArrayView(value);\n      }\n      if (value == null) {\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof value === \"number\") {\n        throw new TypeError(\n          'The \"value\" argument must not be of type number. Received type number'\n        );\n      }\n      const valueOf = value.valueOf && value.valueOf();\n      if (valueOf != null && valueOf !== value) {\n        return Buffer2.from(valueOf, encodingOrOffset, length);\n      }\n      const b = fromObject(value);\n      if (b)\n        return b;\n      if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n        return Buffer2.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n      }\n      throw new TypeError(\n        \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n      );\n    }\n    Buffer2.from = function(value, encodingOrOffset, length) {\n      return from(value, encodingOrOffset, length);\n    };\n    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);\n    Object.setPrototypeOf(Buffer2, Uint8Array);\n    function assertSize(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be of type number');\n      } else if (size < 0) {\n        throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      }\n    }\n    function alloc(size, fill, encoding) {\n      assertSize(size);\n      if (size <= 0) {\n        return createBuffer(size);\n      }\n      if (fill !== void 0) {\n        return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n      }\n      return createBuffer(size);\n    }\n    Buffer2.alloc = function(size, fill, encoding) {\n      return alloc(size, fill, encoding);\n    };\n    function allocUnsafe(size) {\n      assertSize(size);\n      return createBuffer(size < 0 ? 0 : checked(size) | 0);\n    }\n    Buffer2.allocUnsafe = function(size) {\n      return allocUnsafe(size);\n    };\n    Buffer2.allocUnsafeSlow = function(size) {\n      return allocUnsafe(size);\n    };\n    function fromString(string, encoding) {\n      if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n      }\n      if (!Buffer2.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      const length = byteLength(string, encoding) | 0;\n      let buf = createBuffer(length);\n      const actual = buf.write(string, encoding);\n      if (actual !== length) {\n        buf = buf.slice(0, actual);\n      }\n      return buf;\n    }\n    function fromArrayLike(array) {\n      const length = array.length < 0 ? 0 : checked(array.length) | 0;\n      const buf = createBuffer(length);\n      for (let i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n      }\n      return buf;\n    }\n    function fromArrayView(arrayView) {\n      if (isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n      }\n      return fromArrayLike(arrayView);\n    }\n    function fromArrayBuffer(array, byteOffset, length) {\n      if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n      }\n      if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n      }\n      let buf;\n      if (byteOffset === void 0 && length === void 0) {\n        buf = new Uint8Array(array);\n      } else if (length === void 0) {\n        buf = new Uint8Array(array, byteOffset);\n      } else {\n        buf = new Uint8Array(array, byteOffset, length);\n      }\n      Object.setPrototypeOf(buf, Buffer2.prototype);\n      return buf;\n    }\n    function fromObject(obj) {\n      if (Buffer2.isBuffer(obj)) {\n        const len = checked(obj.length) | 0;\n        const buf = createBuffer(len);\n        if (buf.length === 0) {\n          return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n      }\n      if (obj.length !== void 0) {\n        if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n          return createBuffer(0);\n        }\n        return fromArrayLike(obj);\n      }\n      if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data);\n      }\n    }\n    function checked(length) {\n      if (length >= K_MAX_LENGTH) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n      }\n      return length | 0;\n    }\n    function SlowBuffer(length) {\n      if (+length != length) {\n        length = 0;\n      }\n      return Buffer2.alloc(+length);\n    }\n    Buffer2.isBuffer = function isBuffer(b) {\n      return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n    };\n    Buffer2.compare = function compare(a, b) {\n      if (isInstance(a, Uint8Array))\n        a = Buffer2.from(a, a.offset, a.byteLength);\n      if (isInstance(b, Uint8Array))\n        b = Buffer2.from(b, b.offset, b.byteLength);\n      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n        throw new TypeError(\n          'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n        );\n      }\n      if (a === b)\n        return 0;\n      let x = a.length;\n      let y = b.length;\n      for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n          x = a[i];\n          y = b[i];\n          break;\n        }\n      }\n      if (x < y)\n        return -1;\n      if (y < x)\n        return 1;\n      return 0;\n    };\n    Buffer2.isEncoding = function isEncoding(encoding) {\n      switch (String(encoding).toLowerCase()) {\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return true;\n        default:\n          return false;\n      }\n    };\n    Buffer2.concat = function concat(list, length) {\n      if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      }\n      if (list.length === 0) {\n        return Buffer2.alloc(0);\n      }\n      let i;\n      if (length === void 0) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n          length += list[i].length;\n        }\n      }\n      const buffer = Buffer2.allocUnsafe(length);\n      let pos = 0;\n      for (i = 0; i < list.length; ++i) {\n        let buf = list[i];\n        if (isInstance(buf, Uint8Array)) {\n          if (pos + buf.length > buffer.length) {\n            if (!Buffer2.isBuffer(buf))\n              buf = Buffer2.from(buf);\n            buf.copy(buffer, pos);\n          } else {\n            Uint8Array.prototype.set.call(\n              buffer,\n              buf,\n              pos\n            );\n          }\n        } else if (!Buffer2.isBuffer(buf)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        } else {\n          buf.copy(buffer, pos);\n        }\n        pos += buf.length;\n      }\n      return buffer;\n    };\n    function byteLength(string, encoding) {\n      if (Buffer2.isBuffer(string)) {\n        return string.length;\n      }\n      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength;\n      }\n      if (typeof string !== \"string\") {\n        throw new TypeError(\n          'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n        );\n      }\n      const len = string.length;\n      const mustMatch = arguments.length > 2 && arguments[2] === true;\n      if (!mustMatch && len === 0)\n        return 0;\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8ToBytes(string).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n          case \"hex\":\n            return len >>> 1;\n          case \"base64\":\n            return base64ToBytes(string).length;\n          default:\n            if (loweredCase) {\n              return mustMatch ? -1 : utf8ToBytes(string).length;\n            }\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer2.byteLength = byteLength;\n    function slowToString(encoding, start, end) {\n      let loweredCase = false;\n      if (start === void 0 || start < 0) {\n        start = 0;\n      }\n      if (start > this.length) {\n        return \"\";\n      }\n      if (end === void 0 || end > this.length) {\n        end = this.length;\n      }\n      if (end <= 0) {\n        return \"\";\n      }\n      end >>>= 0;\n      start >>>= 0;\n      if (end <= start) {\n        return \"\";\n      }\n      if (!encoding)\n        encoding = \"utf8\";\n      while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n          case \"base64\":\n            return base64Slice(this, start, end);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n          default:\n            if (loweredCase)\n              throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer2.prototype._isBuffer = true;\n    function swap(b, n, m) {\n      const i = b[n];\n      b[n] = b[m];\n      b[m] = i;\n    }\n    Buffer2.prototype.swap16 = function swap16() {\n      const len = this.length;\n      if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      }\n      for (let i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n      }\n      return this;\n    };\n    Buffer2.prototype.swap32 = function swap32() {\n      const len = this.length;\n      if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      }\n      for (let i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n      }\n      return this;\n    };\n    Buffer2.prototype.swap64 = function swap64() {\n      const len = this.length;\n      if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      }\n      for (let i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n      }\n      return this;\n    };\n    Buffer2.prototype.toString = function toString() {\n      const length = this.length;\n      if (length === 0)\n        return \"\";\n      if (arguments.length === 0)\n        return utf8Slice(this, 0, length);\n      return slowToString.apply(this, arguments);\n    };\n    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n    Buffer2.prototype.equals = function equals(b) {\n      if (!Buffer2.isBuffer(b))\n        throw new TypeError(\"Argument must be a Buffer\");\n      if (this === b)\n        return true;\n      return Buffer2.compare(this, b) === 0;\n    };\n    Buffer2.prototype.inspect = function inspect() {\n      let str = \"\";\n      const max = exports.INSPECT_MAX_BYTES;\n      str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n      if (this.length > max)\n        str += \" ... \";\n      return \"<Buffer \" + str + \">\";\n    };\n    if (customInspectSymbol) {\n      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n    }\n    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n      if (isInstance(target, Uint8Array)) {\n        target = Buffer2.from(target, target.offset, target.byteLength);\n      }\n      if (!Buffer2.isBuffer(target)) {\n        throw new TypeError(\n          'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n        );\n      }\n      if (start === void 0) {\n        start = 0;\n      }\n      if (end === void 0) {\n        end = target ? target.length : 0;\n      }\n      if (thisStart === void 0) {\n        thisStart = 0;\n      }\n      if (thisEnd === void 0) {\n        thisEnd = this.length;\n      }\n      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n      }\n      if (thisStart >= thisEnd && start >= end) {\n        return 0;\n      }\n      if (thisStart >= thisEnd) {\n        return -1;\n      }\n      if (start >= end) {\n        return 1;\n      }\n      start >>>= 0;\n      end >>>= 0;\n      thisStart >>>= 0;\n      thisEnd >>>= 0;\n      if (this === target)\n        return 0;\n      let x = thisEnd - thisStart;\n      let y = end - start;\n      const len = Math.min(x, y);\n      const thisCopy = this.slice(thisStart, thisEnd);\n      const targetCopy = target.slice(start, end);\n      for (let i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n          x = thisCopy[i];\n          y = targetCopy[i];\n          break;\n        }\n      }\n      if (x < y)\n        return -1;\n      if (y < x)\n        return 1;\n      return 0;\n    };\n    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n      if (buffer.length === 0)\n        return -1;\n      if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n      } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n      } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n      }\n      byteOffset = +byteOffset;\n      if (numberIsNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n      }\n      if (byteOffset < 0)\n        byteOffset = buffer.length + byteOffset;\n      if (byteOffset >= buffer.length) {\n        if (dir)\n          return -1;\n        else\n          byteOffset = buffer.length - 1;\n      } else if (byteOffset < 0) {\n        if (dir)\n          byteOffset = 0;\n        else\n          return -1;\n      }\n      if (typeof val === \"string\") {\n        val = Buffer2.from(val, encoding);\n      }\n      if (Buffer2.isBuffer(val)) {\n        if (val.length === 0) {\n          return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n          if (dir) {\n            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n          } else {\n            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n          }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n      }\n      throw new TypeError(\"val must be string, number or Buffer\");\n    }\n    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n      let indexSize = 1;\n      let arrLength = arr.length;\n      let valLength = val.length;\n      if (encoding !== void 0) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n          if (arr.length < 2 || val.length < 2) {\n            return -1;\n          }\n          indexSize = 2;\n          arrLength /= 2;\n          valLength /= 2;\n          byteOffset /= 2;\n        }\n      }\n      function read(buf, i2) {\n        if (indexSize === 1) {\n          return buf[i2];\n        } else {\n          return buf.readUInt16BE(i2 * indexSize);\n        }\n      }\n      let i;\n      if (dir) {\n        let foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1)\n              foundIndex = i;\n            if (i - foundIndex + 1 === valLength)\n              return foundIndex * indexSize;\n          } else {\n            if (foundIndex !== -1)\n              i -= i - foundIndex;\n            foundIndex = -1;\n          }\n        }\n      } else {\n        if (byteOffset + valLength > arrLength)\n          byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n          let found = true;\n          for (let j = 0; j < valLength; j++) {\n            if (read(arr, i + j) !== read(val, j)) {\n              found = false;\n              break;\n            }\n          }\n          if (found)\n            return i;\n        }\n      }\n      return -1;\n    }\n    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n      return this.indexOf(val, byteOffset, encoding) !== -1;\n    };\n    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n    };\n    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n    };\n    function hexWrite(buf, string, offset, length) {\n      offset = Number(offset) || 0;\n      const remaining = buf.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = Number(length);\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      const strLen = string.length;\n      if (length > strLen / 2) {\n        length = strLen / 2;\n      }\n      let i;\n      for (i = 0; i < length; ++i) {\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed))\n          return i;\n        buf[offset + i] = parsed;\n      }\n      return i;\n    }\n    function utf8Write(buf, string, offset, length) {\n      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    function asciiWrite(buf, string, offset, length) {\n      return blitBuffer(asciiToBytes(string), buf, offset, length);\n    }\n    function base64Write(buf, string, offset, length) {\n      return blitBuffer(base64ToBytes(string), buf, offset, length);\n    }\n    function ucs2Write(buf, string, offset, length) {\n      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    Buffer2.prototype.write = function write(string, offset, length, encoding) {\n      if (offset === void 0) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n      } else if (length === void 0 && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n      } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n          length = length >>> 0;\n          if (encoding === void 0)\n            encoding = \"utf8\";\n        } else {\n          encoding = length;\n          length = void 0;\n        }\n      } else {\n        throw new Error(\n          \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n        );\n      }\n      const remaining = this.length - offset;\n      if (length === void 0 || length > remaining)\n        length = remaining;\n      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n      }\n      if (!encoding)\n        encoding = \"utf8\";\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"hex\":\n            return hexWrite(this, string, offset, length);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Write(this, string, offset, length);\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return asciiWrite(this, string, offset, length);\n          case \"base64\":\n            return base64Write(this, string, offset, length);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return ucs2Write(this, string, offset, length);\n          default:\n            if (loweredCase)\n              throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    };\n    Buffer2.prototype.toJSON = function toJSON() {\n      return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    };\n    function base64Slice(buf, start, end) {\n      if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n      } else {\n        return base64.fromByteArray(buf.slice(start, end));\n      }\n    }\n    function utf8Slice(buf, start, end) {\n      end = Math.min(buf.length, end);\n      const res = [];\n      let i = start;\n      while (i < end) {\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n          let secondByte, thirdByte, fourthByte, tempCodePoint;\n          switch (bytesPerSequence) {\n            case 1:\n              if (firstByte < 128) {\n                codePoint = firstByte;\n              }\n              break;\n            case 2:\n              secondByte = buf[i + 1];\n              if ((secondByte & 192) === 128) {\n                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                if (tempCodePoint > 127) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 3:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 4:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              fourthByte = buf[i + 3];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                  codePoint = tempCodePoint;\n                }\n              }\n          }\n        }\n        if (codePoint === null) {\n          codePoint = 65533;\n          bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n          codePoint -= 65536;\n          res.push(codePoint >>> 10 & 1023 | 55296);\n          codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n      }\n      return decodeCodePointsArray(res);\n    }\n    var MAX_ARGUMENTS_LENGTH = 4096;\n    function decodeCodePointsArray(codePoints) {\n      const len = codePoints.length;\n      if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n      }\n      let res = \"\";\n      let i = 0;\n      while (i < len) {\n        res += String.fromCharCode.apply(\n          String,\n          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n        );\n      }\n      return res;\n    }\n    function asciiSlice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n      }\n      return ret;\n    }\n    function latin1Slice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n      }\n      return ret;\n    }\n    function hexSlice(buf, start, end) {\n      const len = buf.length;\n      if (!start || start < 0)\n        start = 0;\n      if (!end || end < 0 || end > len)\n        end = len;\n      let out = \"\";\n      for (let i = start; i < end; ++i) {\n        out += hexSliceLookupTable[buf[i]];\n      }\n      return out;\n    }\n    function utf16leSlice(buf, start, end) {\n      const bytes = buf.slice(start, end);\n      let res = \"\";\n      for (let i = 0; i < bytes.length - 1; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n      }\n      return res;\n    }\n    Buffer2.prototype.slice = function slice(start, end) {\n      const len = this.length;\n      start = ~~start;\n      end = end === void 0 ? len : ~~end;\n      if (start < 0) {\n        start += len;\n        if (start < 0)\n          start = 0;\n      } else if (start > len) {\n        start = len;\n      }\n      if (end < 0) {\n        end += len;\n        if (end < 0)\n          end = 0;\n      } else if (end > len) {\n        end = len;\n      }\n      if (end < start)\n        end = start;\n      const newBuf = this.subarray(start, end);\n      Object.setPrototypeOf(newBuf, Buffer2.prototype);\n      return newBuf;\n    };\n    function checkOffset(offset, ext, length) {\n      if (offset % 1 !== 0 || offset < 0)\n        throw new RangeError(\"offset is not uint\");\n      if (offset + ext > length)\n        throw new RangeError(\"Trying to access beyond buffer length\");\n    }\n    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      return val;\n    };\n    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        checkOffset(offset, byteLength2, this.length);\n      }\n      let val = this[offset + --byteLength2];\n      let mul = 1;\n      while (byteLength2 > 0 && (mul *= 256)) {\n        val += this[offset + --byteLength2] * mul;\n      }\n      return val;\n    };\n    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 1, this.length);\n      return this[offset];\n    };\n    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      return this[offset] | this[offset + 1] << 8;\n    };\n    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      return this[offset] << 8 | this[offset + 1];\n    };\n    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n    };\n    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n    };\n    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n      return BigInt(lo) + (BigInt(hi) << BigInt(32));\n    });\n    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n      return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n    });\n    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset, byteLength2, this.length);\n      let i = byteLength2;\n      let mul = 1;\n      let val = this[offset + --i];\n      while (i > 0 && (mul *= 256)) {\n        val += this[offset + --i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 1, this.length);\n      if (!(this[offset] & 128))\n        return this[offset];\n      return (255 - this[offset] + 1) * -1;\n    };\n    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      const val = this[offset] | this[offset + 1] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 2, this.length);\n      const val = this[offset + 1] | this[offset] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n    };\n    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n    };\n    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n    });\n    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n    });\n    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, true, 23, 4);\n    };\n    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, false, 23, 4);\n    };\n    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, true, 52, 8);\n    };\n    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, false, 52, 8);\n    };\n    function checkInt(buf, value, offset, ext, max, min) {\n      if (!Buffer2.isBuffer(buf))\n        throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (value > max || value < min)\n        throw new RangeError('\"value\" argument is out of bounds');\n      if (offset + ext > buf.length)\n        throw new RangeError(\"Index out of range\");\n    }\n    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let mul = 1;\n      let i = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 1, 255, 0);\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset + 3] = value >>> 24;\n      this[offset + 2] = value >>> 16;\n      this[offset + 1] = value >>> 8;\n      this[offset] = value & 255;\n      return offset + 4;\n    };\n    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    function wrtBigUInt64LE(buf, value, offset, min, max) {\n      checkIntBI(value, min, max, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      return offset;\n    }\n    function wrtBigUInt64BE(buf, value, offset, min, max) {\n      checkIntBI(value, min, max, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset + 7] = lo;\n      lo = lo >> 8;\n      buf[offset + 6] = lo;\n      lo = lo >> 8;\n      buf[offset + 5] = lo;\n      lo = lo >> 8;\n      buf[offset + 4] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset + 3] = hi;\n      hi = hi >> 8;\n      buf[offset + 2] = hi;\n      hi = hi >> 8;\n      buf[offset + 1] = hi;\n      hi = hi >> 8;\n      buf[offset] = hi;\n      return offset + 8;\n    }\n    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = 0;\n      let mul = 1;\n      let sub = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      let sub = 0;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 1, 127, -128);\n      if (value < 0)\n        value = 255 + value + 1;\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      this[offset + 2] = value >>> 16;\n      this[offset + 3] = value >>> 24;\n      return offset + 4;\n    };\n    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      if (value < 0)\n        value = 4294967295 + value + 1;\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    function checkIEEE754(buf, value, offset, ext, max, min) {\n      if (offset + ext > buf.length)\n        throw new RangeError(\"Index out of range\");\n      if (offset < 0)\n        throw new RangeError(\"Index out of range\");\n    }\n    function writeFloat(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      return offset + 4;\n    }\n    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, true, noAssert);\n    };\n    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, false, noAssert);\n    };\n    function writeDouble(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      return offset + 8;\n    }\n    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, true, noAssert);\n    };\n    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, false, noAssert);\n    };\n    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n      if (!Buffer2.isBuffer(target))\n        throw new TypeError(\"argument should be a Buffer\");\n      if (!start)\n        start = 0;\n      if (!end && end !== 0)\n        end = this.length;\n      if (targetStart >= target.length)\n        targetStart = target.length;\n      if (!targetStart)\n        targetStart = 0;\n      if (end > 0 && end < start)\n        end = start;\n      if (end === start)\n        return 0;\n      if (target.length === 0 || this.length === 0)\n        return 0;\n      if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n      }\n      if (start < 0 || start >= this.length)\n        throw new RangeError(\"Index out of range\");\n      if (end < 0)\n        throw new RangeError(\"sourceEnd out of bounds\");\n      if (end > this.length)\n        end = this.length;\n      if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n      }\n      const len = end - start;\n      if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n        this.copyWithin(targetStart, start, end);\n      } else {\n        Uint8Array.prototype.set.call(\n          target,\n          this.subarray(start, end),\n          targetStart\n        );\n      }\n      return len;\n    };\n    Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n      if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n          encoding = start;\n          start = 0;\n          end = this.length;\n        } else if (typeof end === \"string\") {\n          encoding = end;\n          end = this.length;\n        }\n        if (encoding !== void 0 && typeof encoding !== \"string\") {\n          throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        if (val.length === 1) {\n          const code = val.charCodeAt(0);\n          if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n            val = code;\n          }\n        }\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n      } else if (typeof val === \"boolean\") {\n        val = Number(val);\n      }\n      if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n      }\n      if (end <= start) {\n        return this;\n      }\n      start = start >>> 0;\n      end = end === void 0 ? this.length : end >>> 0;\n      if (!val)\n        val = 0;\n      let i;\n      if (typeof val === \"number\") {\n        for (i = start; i < end; ++i) {\n          this[i] = val;\n        }\n      } else {\n        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) {\n          throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        }\n        for (i = 0; i < end - start; ++i) {\n          this[i + start] = bytes[i % len];\n        }\n      }\n      return this;\n    };\n    var errors = {};\n    function E(sym, getMessage, Base) {\n      errors[sym] = class NodeError extends Base {\n        constructor() {\n          super();\n          Object.defineProperty(this, \"message\", {\n            value: getMessage.apply(this, arguments),\n            writable: true,\n            configurable: true\n          });\n          this.name = `${this.name} [${sym}]`;\n          this.stack;\n          delete this.name;\n        }\n        get code() {\n          return sym;\n        }\n        set code(value) {\n          Object.defineProperty(this, \"code\", {\n            configurable: true,\n            enumerable: true,\n            value,\n            writable: true\n          });\n        }\n        toString() {\n          return `${this.name} [${sym}]: ${this.message}`;\n        }\n      };\n    }\n    E(\n      \"ERR_BUFFER_OUT_OF_BOUNDS\",\n      function(name) {\n        if (name) {\n          return `${name} is outside of buffer bounds`;\n        }\n        return \"Attempt to access memory outside buffer bounds\";\n      },\n      RangeError\n    );\n    E(\n      \"ERR_INVALID_ARG_TYPE\",\n      function(name, actual) {\n        return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n      },\n      TypeError\n    );\n    E(\n      \"ERR_OUT_OF_RANGE\",\n      function(str, range, input) {\n        let msg = `The value of \"${str}\" is out of range.`;\n        let received = input;\n        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n          received = addNumericalSeparator(String(input));\n        } else if (typeof input === \"bigint\") {\n          received = String(input);\n          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n            received = addNumericalSeparator(received);\n          }\n          received += \"n\";\n        }\n        msg += ` It must be ${range}. Received ${received}`;\n        return msg;\n      },\n      RangeError\n    );\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    function checkBounds(buf, offset, byteLength2) {\n      validateNumber(offset, \"offset\");\n      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n        boundsError(offset, buf.length - (byteLength2 + 1));\n      }\n    }\n    function checkIntBI(value, min, max, buf, offset, byteLength2) {\n      if (value > max || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        if (byteLength2 > 3) {\n          if (min === 0 || min === BigInt(0)) {\n            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n          } else {\n            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n          }\n        } else {\n          range = `>= ${min}${n} and <= ${max}${n}`;\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n      }\n      checkBounds(buf, offset, byteLength2);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") {\n        throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n    }\n    function boundsError(value, length, type) {\n      if (Math.floor(value) !== value) {\n        validateNumber(value, type);\n        throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n      }\n      if (length < 0) {\n        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n      }\n      throw new errors.ERR_OUT_OF_RANGE(\n        type || \"offset\",\n        `>= ${type ? 1 : 0} and <= ${length}`,\n        value\n      );\n    }\n    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n    function base64clean(str) {\n      str = str.split(\"=\")[0];\n      str = str.trim().replace(INVALID_BASE64_RE, \"\");\n      if (str.length < 2)\n        return \"\";\n      while (str.length % 4 !== 0) {\n        str = str + \"=\";\n      }\n      return str;\n    }\n    function utf8ToBytes(string, units) {\n      units = units || Infinity;\n      let codePoint;\n      const length = string.length;\n      let leadSurrogate = null;\n      const bytes = [];\n      for (let i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n          if (!leadSurrogate) {\n            if (codePoint > 56319) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              continue;\n            } else if (i + 1 === length) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              continue;\n            }\n            leadSurrogate = codePoint;\n            continue;\n          }\n          if (codePoint < 56320) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n            leadSurrogate = codePoint;\n            continue;\n          }\n          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n          if ((units -= 1) < 0)\n            break;\n          bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n          if ((units -= 2) < 0)\n            break;\n          bytes.push(\n            codePoint >> 6 | 192,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 65536) {\n          if ((units -= 3) < 0)\n            break;\n          bytes.push(\n            codePoint >> 12 | 224,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 1114112) {\n          if ((units -= 4) < 0)\n            break;\n          bytes.push(\n            codePoint >> 18 | 240,\n            codePoint >> 12 & 63 | 128,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else {\n          throw new Error(\"Invalid code point\");\n        }\n      }\n      return bytes;\n    }\n    function asciiToBytes(str) {\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        byteArray.push(str.charCodeAt(i) & 255);\n      }\n      return byteArray;\n    }\n    function utf16leToBytes(str, units) {\n      let c, hi, lo;\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0)\n          break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n      }\n      return byteArray;\n    }\n    function base64ToBytes(str) {\n      return base64.toByteArray(base64clean(str));\n    }\n    function blitBuffer(src, dst, offset, length) {\n      let i;\n      for (i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length)\n          break;\n        dst[i + offset] = src[i];\n      }\n      return i;\n    }\n    function isInstance(obj, type) {\n      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n    }\n    function numberIsNaN(obj) {\n      return obj !== obj;\n    }\n    var hexSliceLookupTable = function() {\n      const alphabet = \"0123456789abcdef\";\n      const table = new Array(256);\n      for (let i = 0; i < 16; ++i) {\n        const i16 = i * 16;\n        for (let j = 0; j < 16; ++j) {\n          table[i16 + j] = alphabet[i] + alphabet[j];\n        }\n      }\n      return table;\n    }();\n    function defineBigIntMethod(fn) {\n      return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n    }\n    function BufferBigIntNotDefined() {\n      throw new Error(\"BigInt not supported\");\n    }\n  }\n});\n\n// src/fakeModules/buffer.js\nvar import_buffer;\nvar init_buffer = __esm({\n  \"src/fakeModules/buffer.js\"() {\n    \"use strict\";\n    import_buffer = __toESM(require_buffer());\n  }\n});\n\nexport {\n  __require,\n  __esm,\n  __commonJS,\n  __export,\n  __toESM,\n  __toCommonJS,\n  process,\n  init_process,\n  require_buffer,\n  import_buffer,\n  init_buffer\n};\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}